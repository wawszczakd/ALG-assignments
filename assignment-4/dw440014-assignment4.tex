\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{indentfirst}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{natbib}
\usepackage{graphicx}
\usepackage{float}
\usepackage[a4paper, margin = 2 cm]{geometry}
\usepackage{fancyhdr}
\usepackage{wrapfig}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{algorithm}
\usepackage{algpseudocode}

\title{Algorytmika praca domowa 4}
\author{Dominik Wawszczak}
\date{2024-06-06}

\begin{document}
	\setlength{\parindent}{0 cm}
	
	Dominik Wawszczak \hfill Algorytmika
	
	numer indeksu: 440014 \hfill praca domowa 4
	
	numer grupy: 1
	
	\bigskip
	\hrule
	\bigskip
	
	\textbf{Zadanie 1}
	
	\medskip
	
	Skoro w każdej klauzuli każda zmienna występuje w co najwyżej jednym
	literale, to zbiór \(X\) jest zbiorem rozwiązującym wtedy i tylko wtedy, gdy
	każda klauzula zawiera co najwyżej dwie zmienne niebędące w \(X\). Wynika z
	tego, że jeśli \(X\) nie jest zbiorem rozwiązującym, to istnieje klauzula,
	która zawiera przynajmniej \(3\) zmienne niebędące w \(X\). Obserwacja ta
	prowadzi do następującego algorytmu:
	
	\begin{algorithm}
		\caption{SolvingSet}
		\begin{algorithmic}[1]
			\Procedure{SolvingSet}{$k, X = \emptyset$}
			    \If{every clause has at most two variables not in $X$}
			        \State \Return true
			    \EndIf
			    \If{$k \leqslant 0$}
			        \State \Return false
			    \EndIf
			    \State $(a, b, c) \gets$ three variables not in $X$ from one
			    clause
			    \State \Return \Call{SolvingSet}{$k - 1, X \cup \{a\}$}
			    \textbf{or} \Call{SolvingSet}{$k - 1, X \cup \{b\}$} \textbf{or}
			    \Statex \hspace{4.685em} \Call{SolvingSet}{$k - 1, X \cup \{c\}$}
		\EndProcedure
		\end{algorithmic}
	\end{algorithm}
	
	Algorytm ten wykorzystuje fakt, że jeśli aktualny zbiór \(X\) jest
	podzbiorem pewnego zbioru rozwiązującego, to przynajmniej jedna ze zmiennych
	\(a\), \(b\) lub \(c\) musi być w tym zbiorze.
	
	\medskip
	
	W drzewie rekurencji tego algorytmu, na \(i\)-tym poziomie głębokości jest
	co najwyżej \(3^{i}\) wierzchołków, dla \(i = 0, \ldots, k\). Łącznie
	daje to maksymalnie \(\frac{3^{k + 1} - 1}{2}\) wywołań rekurencyjnych. W
	każdym wywołaniu musimy jedynie znaleźć odpowiednią klauzulę i wybrać z niej
	trzy zmienne, bądź stwierdzić, że taka klauzula nie istnieje, co oczywiście
	da się zrobić w czasie \(|\varphi|^{O(1)}\). Ostateczna złożoność czasowa
	naszego algorytmu wynosi zatem \(3^{k} \cdot |\varphi|^{O(1)}\), co kończy
	rozwiązanie pierwszej części zadania.
	
	\medskip
	
	Przejdźmy teraz do rozwiązania drugiej części zadania. Bez straty ogólności
	możemy założyć, że dekompozycja drzewowa jest ładna. Skorzystamy z
	programowania dynamicznego. Niech \(v\) będzie dowolnym wierzchołkiem
	dekompozycji drzewowej. Dla każdej pary funkcji \(f : \text{zmienne}(v) \to
	\{0, 1\}\) oraz \(g : \text{klauzule}(v) \to \{0, 1, 2\}\) definiujemy
	\begin{align*}
		\text{dp}(v, f, g) \ = \ \min \bigg\{ &|X| \ : \ X \cap
		\text{zmienne}(v) = f^{-1}(1) \ \wedge \ \underset{l \in
		\text{klauzule}(v)}{\forall} |l	\setminus X| = g(l) \ \wedge \\
		&\underset{l \in \text{klauzule}(T_{v})}{\forall} |l \setminus X|
		\leqslant 2 \bigg\} \text{,}
	\end{align*}
	gdzie \(T_{v}\) jest poddrzewem wierzchołka \(v\), a klauzule traktujemy
	jako zbiory zmiennych, które zawierają.
	
	\medskip
	
	Tak zdefiniowaną tablicę można łatwo wypełnić, rozważając \(5\) przypadków
	(dodanie/usunięcie zmiennej/klauzuli oraz wierzchołek łączący dwóch synów).
	Na koniec wystarczy odczytać wartość z \(\text{dp}(\text{root}, \emptyset,
	\emptyset)\) i jeśli jest ona nie większa niż \(k\), to odpowiedzią jest
	,,Tak''. W przeciwnym wypadku odpowiedzią jest ,,Nie''.
	
	\medskip
	
	Całkowita złożoność naszego algorytmu to \(3^{t} \cdot |\varphi|^{O(1)}\),
	co kończy rozwiązanie zadania.
	
	\newpage
	
	\textbf{Zadanie 2}
	
	\medskip
	
\end{document}
